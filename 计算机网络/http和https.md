# http

## 抓包

- 请求 三部分

  请求方式（post/get/delete/put）  url   http版本

  头部信息

  数据

- 响应 三部分

  http版本  响应状态码 状态吗对应的原因

  头部信息

  返回信息

## 特点

- 无状态：两次请求无关联，不知道上次请求了啥

  cookie 客户端可保存一些状态信息

  session 服务端保存一些状态信息

- 通信明文

  Https  ： 在tcp层和http层中间加了一层SSL/TLS

## 缺点

- 明文，可能会被窃听，需要加密
- 可能会被伪造，需要验证
- 篡改，需要验证报文完整性



# https <重要>

- 个人理解：通过非对称密钥协商对称密钥，通过对称密钥传输信息。由于非对称密钥的公钥传给客户端时可能会被伪造或篡改，可以通过第三方CA认证。
- 个人理解大致过程：
  - 服务器申请证书：服务器向CA机构申请证书，会给CA机构发送自己的公钥，CA机构会首先使用然后通过摘要算法对服务器公钥进行摘要，然后自己的私钥给摘要加密形成最终的证书，然后发给服务器。
  - 客户端请求服务器：当客户端向服务器发送请求时，服务器会将证书发给客户端，客户端会通过浏览器里内置的CA机构的公钥对证书解密，得到摘要；然后通过摘要算法对数据重新进行摘要，如果两个摘要一致，证明内容没有被篡改。然后客户端就获得了服务器的公钥，之后就可以通过非对称加密来协商对称密钥了。



![image-20200309152316378](http%E5%92%8Chttps.assets/image-20200309152316378.png)





通信原理演进

![image-20200222015321063](http%E5%92%8Chttps.assets/image-20200222015321063.png)

如何保证传输安全？加密！

对称加密？

- 计算简单，加解密快
- 如何协商密钥，密钥如何传输？

- 多客户端情况下，服务器维护困难？

非对称加密？

- 公钥私钥不同，由算法生成

- 计算复杂，加解密慢

- 建立连接时，服务器分配公钥给客户端？中间人冒充问题怎么解决？

  

![image-20200222020956300](http%E5%92%8Chttps.assets/image-20200222020956300.png)



**引入第三方**！！！

第三方要证明客户端确实收到的是服务器端发送的公钥

![image-20200309152431473](http%E5%92%8Chttps.assets/image-20200309152431473.png)







