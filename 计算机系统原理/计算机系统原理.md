# 深入理解计算机系统

## 8.异常控制流

本章主要学习应用是如何与操作系统交互的，将描述存在于一个计算机系统中所有层次上的各种形式的ECF。

从异常开始，异常位于硬件和操作系统交界的部分；

然后讨论系统调用，他们为程序提供到错做系统的入口点的异常；

然后描述进程和信号，他们位于应用和操作系统的交界之处；

最后讨论非本地跳转，这是ECF的一种应用层形式

### 8.1 异常

#### 8.1.1 异常处理

异常表的起始地址放在异常表基址寄存器中

![image-20200319134003693](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200319134003693.png)

- 类似于过程调用，跳转到处理程序之前，处理器将返回地址压入栈中，然而，根据异常的类型，返回地址要么是当前指令，要么是下一条指令
- 处理器也会把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序需要这些状态
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈里，而不是压到用户栈里
- 异常处理程序运行在内核模式下，意味着所有系统资源都有完全的访问权限

#### 8.1.2 异常类别

![image-20200319134740970](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200319134740970.png)







## 9.虚拟内存

虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的私有的地址空间。

- 三个重要能力

  1）将主存看成一个存储在磁盘上的地址空间的高速缓存，在内存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据

  2）为每个进程提供了一致的地址空间，简化内存管理

  3）保护了每个进程的地址空间不被其他进程破坏

本章节分两部分，第一部分描述虚拟内存如何工作，第二部分描述应用程序如何使用和管理虚拟内存



### 9.1 物理和虚拟寻址

早期PC使用物理寻址，现在很多嵌入式微控制器等还在使用这种寻址方式

现代处理器使用虚拟寻址方式，CPU通过虚拟地址访问主存，在送到内存前会被转换为物理地址

![image-20200305120732476](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305120732476.png)



### 9.2 地址空间

一个非负整数地址的有序集合

虚拟地址空间：现代系统通常支持32位或64位虚拟地址空间

物理地址空间：系统中物理内存的地址空间

### 9.3 虚拟内存作为缓存的工具

- 页表存放在物理内存，存储物理页号或磁盘地址，地址翻译查看页表，操作系统更新页表

概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，每字节都有一个唯一的虚拟地址。磁盘上数组的内容被缓存到主存中。

VP 虚拟页  virtual page 

PP 物理页，也称为页帧 physical page

 虚拟页面分为三种类型，未分配，未缓存，缓存

![image-20200305114217403](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305114217403.png)

#### 9.3.1 DRAM缓存的组织结构 （缓存与替换算法未看）

SRAM缓存：位于CPU和主存之间的L1,L2,L3高速缓存

DRAM：虚拟内存系统的缓存，在主存中缓存虚拟页

DRAM不命中的开销很大（DRAM比SRAM慢10倍，磁盘比DRAM慢100 000多倍）；磁盘的一个扇区读第一个字节的时间比读这个扇区中连续的自己要慢大于100 000倍。

- 由于大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常在4kb～2mb；

- 由于大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何物理页中
- 操作系统对DRAM缓存使用了复杂精密的替换算法
- 因为对磁盘访问时间很长，DRAM缓存总是使用写回，而不是直写

#### 9.3.2 页表

- 寻址：存放在物理内存中的页表+操作系统+MMU(内存管理单元)中的地址翻译硬件的配合：
  - 页表将虚拟页映射到物理页
  - 地址翻译硬件将一个虚拟地址转换为物理地址时会读取页表
  - 操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页

- 页表条目PTE Page Table Entry：有效位+地址  

  - 有效位1表示已缓存，地址为物理地址(物理页起始位置)
  - 0表示未缓存
    - 地址为空表示未分配
    - 地址不为空表示虚拟页在磁盘上的起始地址

  ![image-20200305120603118](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305120603118.png)

#### 9.3.3 页命中

缓存命中

#### 9.3.4 缺页

- 缓存不命中：触发缺页异常->调用缺页异常处理程序选择牺牲页->牺牲页如果有修改，则写回磁盘->内核从磁盘将访问内容复制到内存的牺牲页，更新页表->异常处理程序返回时重新启动导致缺页的指令->命中

![image-20200305121752349](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305121752349.png)

![image-20200305121808985](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305121808985.png)

- 磁盘和内存之间传送页的活动叫做**交换或页面调度**，页从磁盘调入DRAM和从DRAM调出磁盘。只有当不命中时才进行换入页面，这种策略叫按**需页面调度**

#### 9.3.5 分配页面

分配新的虚拟页时，对页表的影响，比如调用malloc需要分配VP5，还是上图，则会在磁盘创建空间并更新PTE5 ，使它指向磁盘上这个新创建的页面

![image-20200305122529925](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305122529925.png)

#### 9.3.6 局部性

尽管程序引用的页面总数可能超过物理内存总大小，但局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合就叫工作集

如果工作集的大小超过了物理内存的代销，则会产生抖动，即页面不断换进换出。

#### Toolkit 1 统计缺页次数

- getrusage函数检测缺页数量

### 9.4 虚拟内存作为内存管理的工具

- 操作系统为每个进程提供了一个独立的页面，因而也就是一个独立的虚拟地址空间

- 内存管理：按需页面调度+虚拟地址空间
  - 简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式（见图8-13）：对于64位地址空间，代码段总是在虚拟地址0x400000开始，数据段跟在代码段之后，中间有对齐空白，栈占据用户进程地址空间的最高的部分，并向下生长，这样的一致性极大的简化了链接器的设计与实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。
  - 简化加载：按需页面调度
  - 简化共享：对于一些每个进程都需要的，比如内核代码，操作系统会将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享
  - 简化内存分配：当用户要求额外的堆空间时，如调用malloc的结果，操作系统分配一个适当数字例如k各连续的虚拟内存页面，并将它们映射到物理内存中任意位置的k个任意的物理页面

### 9.5 虚拟内存作为内存保护的工具

- 页表条目添加三个许可位

  - SUP：表示进程是否必须运行在内核模式下才能访问该页
  - READ：读访问权限
  - WRITE：写访问权限

- 如果一条指令违反了这些许可条件，CPU会触发一个一般保护故障，将控制传递给一个内核中的异常处理程序，Linxu shell一般称这种异常报告为“段错误”

  ![image-20200305143323622](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305143323622.png)

  

### 9.6 地址翻译 <重要>

- MMU如何利用页表实现地址转换

![image-20200305143835926](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305143835926.png)

- 页面命中时，CPU硬件执行步骤

  ![image-20200305144045687](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305144045687.png)

- 缺页时处理

  ![image-20200305144334353](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305144334353.png)

  ![image-20200305144435693](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305144435693.png)

  ![image-20200305144450155](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305144450155.png)

#### 9.6.1 结合高速缓存和虚拟内存

- 对于高速缓存的访问，大多数是通过物理寻址；高速缓存不需要处理保护问题，因为访问权限的检查是在地址翻译过程的一部分；地址翻译发生在高速缓存查找之前

  ![image-20200305145040348](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305145040348.png)

#### 9.6.2 利用TLB加速地址翻译

- 现在每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE，这就要求每次得从内存取一次数据，当然可能会在高速缓存里，许多系统都试图消除这样的开销。从而引入了TLB (Translation Lookaside Buffer) 翻译后备缓冲区，一个关于PTE的小缓存被包含在了MMU里

- TLB命中和不命中的操作

  ![image-20200305145947889](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305145947889.png)

#### 9.6.3 多级页表

- 如果只使用一级页表，假设物理地址空间有4G，那一个页4K，那么需要页表条目1M，每个条目占据4Byte，即内存中需要有一个4MB的页表常驻，压力较大

- 二级页表：一级页表指示为空的二级页表就不存在

  ![image-20200305150846737](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305150846737.png)

- 多级页表的地址翻译

  ![image-20200305150942065](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305150942065.png)

#### 9.6.4 综合：端到端的地址翻译

（略）

### 9.7 案例研究：Intel Core i7/Linux 内存系统

#### 9.7.1 Core i7地址翻译

（略）

#### 9.7.2 Linux虚拟内存系统<重要>

![image-20200305155115525](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305155115525.png)

- Linux虚拟内存区域

  Linux将虚拟内存组织称一些区域(也叫做段)的集合。一个区域是已经存在的(已分配的)虚拟内存的连续片，这些页以某种方式相关联的。

  例如，代码段，数据段，堆，共享库段，以及用户栈都是不同的区域，每个存在的虚拟页面都保存在某个区域中。内核不需要记录那些不存在的虚拟页，这样的页不占用内存，磁盘或者内核本身中任何额外资源。

  - Linux对虚拟内存的组织

    ![image-20200305160003562](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305160003562.png)

    ![image-20200305160028100](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305160028100.png)

    

- Linux缺页异常处理

  ![image-20200305160423498](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305160423498.png)

  当MMU在试图翻译某个虚拟地址A时，触发了一个缺页，这个异常导致控制转移到内核的缺页处理程序：

  - 虚拟地址A合法吗？即在区域结构里吗？扫描区域结构的vm_start和vm_end，判断是否在区域内，如果不在触发段错误。 
    - 因为一个进程可以创建任意数量的心虚拟内存区域（mmap函数），在实际中，Linux构建了一棵树，以便查找
  - 内存访问是否合法？根据页表里的内存保护位判断进程访问是否合法。比如运行在用户模式下的进程试图访问内核虚拟内存，则会触发保护异常
  - 如果合法，则会进行正常缺页的处理

### 9.8 内存映射（重要）

Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程叫做内存映射。

虚拟内存区域可以映射到两种类型中的对象中的一种：

- Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需页面调度，因此这些虚拟页面并没有进入物理内存，直到第一次访问。如果区域比文件区大， 那么就用零来填充区域余下部分
- 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果页面被修改过就将这个页面换出来，用二进制零覆盖牺牲页面，并更新页表。
  - 这种方式在磁盘和内存之间并没有进行数据传送，因此，映射到匿名文件的区域中的页面有时候也叫做请求二进制零的页

无论是哪种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去，交换文件也叫做交换区域。在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。（没看懂，自己理解是虚拟页面被初始化后就会在交换区和内存间调入调出）

#### 9.8.1 再看共享对象

- 共享对象：如果一个进程1映射了某个共享对象，另一个进程2也要将该共享对象映射到自己的地址空间时，由于对象都有唯一的文件名，因此内核可以很迅速的判定进程1已经映射了这个对象，然后使进程2的页表条目指向相应的物理页面

  ![image-20200305164335245](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305164335245.png)

- 私有对象：利用了写时复制。 私有对象开始生命周期的方式与共享对象一样，在物理内存中只保存有私有对象的一份副本。且会被标记为只读，但区域结构被标记为私有的写时复制。当进程试图写自己的私有区域时，会触发一个保护异常。

  - 当故障处理程序注意到保护异常是因为进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，恢复这个页面的可写权限，重新执行这个写操作即可

  ![image-20200305164834495](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305164834495.png)

#### 9.8.2 再看fork函数

- fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct，区域结构和页表的原样副本。它将两个进程中每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制。
- 当fork在新进程中返回时，新进程现在的虚拟空间刚好和调用fork时存在的虚拟内存相同，当这两个进程中任何一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念

#### 9.8.3 再看execve函数

   理解execve("a.out",NULL,NULL)，用a.out程序有效替代当前程序，加载并运行a.out需要以下几个步骤：

- 删除已存在的用户区域：删除当前进程虚拟地址的用户部分中已经存在的区域结构

- 映射私有区域：为新程序的代码，数据，bbs和栈区域创建新的区域结构。所有这些新的区域都是私有的，写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区，bbs区域是请求二进制零的，映射到匿名文件，大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。

- 映射共享区域：如果a.out程序与共享对象(或目标)链接，比如标准C库libc.so，那么这些对象都是动态链接到程序的，然后再映射到用户虚拟地址空间中的共享区域内

- 设置程序计数器(PC)：execve做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点

  ![image-20200305172305090](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305172305090.png)

  

#### 9.8.4 使用mmap函数的用户级内存映射

- mmap

![image-20200305174248864](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305174248864.png)

![image-20200305174443654](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305174443654.png)

- munmap：删除虚拟内存区域，再访问会报段错误

![image-20200305174357450](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305174357450.png)



### 9.9 动态内存分配

动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，指向堆的顶部。

分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显示保留为应用程序使用，空闲块用来分配。

分配器有两种风格：

- 显式分配器：显式释放已分配块，例如C标准库，提供malloc分配块和free释放块
- 隐式分配器：也叫垃圾收集器，自动释放未使用的已分配块，例如java

#### 9.9.1 malloc和free函数

![image-20200305180336012](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305180336012.png)

malloc函数返回一个指针，指向大小为至少size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。在32位模式中，malloc返回的块的地址总是8的倍数，在64位模式中，总是16的倍数

动态分配内存器，例如malloc，可以通过使用mmap和munmap函数显示分配和释放堆内存，或者还可以使用sbrk函数。

![image-20200305180727118](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305180727118.png)

sbrk函数通过将内核中brk指针增加incr来扩展和收缩堆。如果成功，将返回brk的旧值，否则就返回-1.



#### 9.9.2 为什么要使用动态内存分配

经常直到程序实际运行时，才知道某些数据结构的大小

#### 9.9.3 分配器的要求和目标

略

#### 9.9.4 碎片

造成堆利用率很低的原因是一种称为碎片的现象

内部碎片：已分配块比有效载荷大

外部碎片：空闲内存合计起来能够满足分配请求，但没有一个单独的空闲块可满足分配请求

#### 9.9.5 实现问题

- 空闲块组织：如何记录空闲块
- 放置：如何选择合适的空闲块来放置一个新分配的块
- 分割：将一个新分配的块放置到某个空闲块之后，如何处理空闲块的剩余部分
- 合并：如何处理一个刚刚释放的块

#### 9.9.6 隐式空闲链表

块大小总是8的倍数，因此最低三位总是0，可以使用一位来表示块是否分配

![image-20200305183149234](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305183149234.png)

隐式空闲链表是指：空闲块通过头部中的大小字段隐含的连接着，分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合

![image-20200305183659925](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305183659925.png)

优点：简单

缺点：搜索空闲链表，与堆中已分配块和空闲块的总数呈线性关系

#### 9.9.7 放置已分配块

- 首次适配
- 下一次适配
- 最佳适配

#### 9.9.8 分割空闲块



#### 9.9.9 获取额外的堆内存

当分配器不能为请求块找到合适的空闲块将会发生什么？

- 合并在相邻的空闲块，如果还不能满足，则分配器会调用sbrk函数，向内核请求额外的堆内存，分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中

#### 9.9.10 合并空闲块

- 立即合并：常数时间合并，但可能会产生大量不必要的分割和合并
- 推迟合并：分配请求失败后，扫描整个堆进行合并空闲块

#### 9.9.11 带边界标记的合并

![image-20200305184931356](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305184931356.png)

- 缺点：当操作很多小块时，头部和脚部产生很多不必要的开销
- 优化：合并主要是合并空闲块，因此可以将前面非空闲块的已分配/空闲位存放在当前块头部多出来的低位中，这样已分配块就不需要占用脚部了，从而节省了开销。空闲块仍旧需要尾部，因为合并时需要知道大小

#### 9.9.12 实现一个简单的分配器

略

#### 9.9.13 显式空闲链表

在空闲块里存放两个指针，形成双向空闲链表

![image-20200305185752121](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200305185752121.png)

维护空闲链表

- 释放后放到链表开头
- 按照地址顺序维护链表

#### 9.9.14 分离的空闲链表

维护多个空闲链表，每个链表中的块有大致相等的大小

略



### 9.10 垃圾收集

#### 9.10.1 垃圾收集器的基本知识

- 识别垃圾-可达图：垃圾收集器将内存视为一张有向可达图，该图的节点被分成一组根节点和一组堆节点。每个堆节点对应于堆中的一个已分配块，根节点不在堆中，包含指向堆的指针，这些位置可以在寄存器，栈里的变量，或者是虚拟内存中读写数据区域内的全局变量。

![image-20200306002658636](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/image-20200306002658636.png)

- java垃圾回收：像java这样语言的垃圾收集器，对应用如何创建和使用指针有很严格的控制，能够维持可达图的一种精确表示，因此也就能够回收所有垃圾。

- C垃圾回收：然而， 像c和c++这样语言的收集器通常不能维持可达图的精确表示。这样的收集器也叫保守垃圾收集器，即每个可达块都被正确标记为可达了，而一些不可达节点却可能被错误的标记为可达。

- 流程：需要堆空间时，应用会调用malloc。如果malloc找不到一个合适的空闲块，那就会调用垃圾收集器，希望能够回收一些垃圾到空闲链表。收集器识别出垃圾后，会调用free，将他们返还给堆。之后malloc重试，如果还是失败了，那就向操作系统要求额外的内存。最后，malloc返回一个只想请求块的指针。

#### 9.10.2 Mark&Sweep垃圾回收器

- 原理：标记阶段标记出根节点的所有可达的和已分配的后继，清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来进行标记

#### 9.10.3 C程序的保守Mark&Sweep

对于C语言来说，Mark&Sweep收集有一些挑战：

- 一，C不会用任何类型信息来标记内存位置，没有一种明显的方式来判断p是不是一个指针
- 二，即使知道p是一个指针，也没有明显方式来判断p是否指向一个已分配块的有效载荷中的某个位置

对于第二个问题，可以将已分配块集合维护成一个平衡二叉树，左子树所有块放在较小地址，右子树放在较大地址。

- 保守的Mark&Sweep：C程序的Mark&Sweep收集器必须是保守的，因为C语言不会用类型信息标记内存位置。因此，像int或者float都可以伪装为指针。假设某个可达的已分配块在它的有效载荷里包含一个int，其值碰巧对应于某个其他已分配块b的有效载荷中的一个地址。对收集器而言，无法推断这个数据实际是int不是指针。因此会保守标记b为可达，尽管事实上它不可达。

### 9.11 C程序中常见的与内存有关的错误

- 间接引用坏指针，比如scanf
- 读未初始化的内存：比如动态分配的int数组不应该默认为0
- 允许栈缓冲区溢出
- 假设指针和他们指向的对象是相同大小
- 造成错位错误：数组引用超过最大下标
- 引用指针，而不是它指向的对象
- 误解指针预算
- 引用不存在的变量
- 引用空闲对块中的数据：free后还用
- 内存泄露