## 1.认识线程

### 1.1代码演示

```c++
void* pth_fun(void* pth_arg){ //参数和返回值类型均为void*
  printf("the thread");
  return NULL;
}


int main(void){
  pthread_t TID=0;
  //int pthread_create(pthread_t* thread,const pthread_attr_t* attr,void*(*start_routine)(void *),void* arg);
  pthread_create(&TID,NULL,pth_fun,NULL);
  ...
}


```

## 2.进程和线程

- 进程缺点
  - 进程间切换消耗大
  - 进程间通信开销也大

- 线程开销低
  - 线程就类似于函数间切换
  - 函数间通信，可以使用参数或使用全局变量

- 进程与线程

进程中线程共享进程资源，打开的文件描述符，全局变量，函数等

- 每个线程拥有自己独立的ID
- 每个线程都有自己独立的函数栈
- 线程有自己的错误号，不是通过设置errno实现，而是直接将错误号返回
- 每个线程都有自己独立的task_struct结构，存放线程信息

## 3.使用场景

- 程序涉及多线任务，使用线程
- 程序涉及运行新程序，使用多进程(大多操作系统负责，比如命令行，图形界面就会创建子进程)

## 4.线程函数

pthread_create/Pthread_join/Pthread_detach/Pthread_cancel/Pthread_exit

进程函数由操作系统提供，线程函数为了不给os增加负担，同时为了提高线程灵活性，由单独的线程库来提供，当然线程库在实现时，也是调用相应的系统API

## 5.pthread_create-1

```c++
int pthread_create(pthread_t* thread,const pthread_attr_t* attr,void*(*start_routine)(void*),void* arg);
```

## 6.pthread_create-2

- gcc编译时，添加-pthread
- 次线程结束，没事；主线程结束，进程结束，即子线程也结束，所以主线程不能结束

## 7.pthread_cancel && pthread_exit

```c++
pthread_cancel(pthread_t tid); //比较粗暴，另一个线程可以停止tid线程，这种情况，tid线程返回值为-1
//注意：停止其他线程尽量使用全局变量自然退出

pthread_exit(void* retval); //主动终止线程,retval为线程结束的返回值

pthread_self(); //获取线程id
```

## 8.pthread_join && pthread_detach

```c++
int pthread_join(pthread_t thread, void** retval);//阻塞等待thread次线程结束，结束时会回收线程占用的资源，retval存储次线程的返回值

pthread_detach(pthread_t thread);//thread线程结束时会自动回收资源

```

## 9.注册线程退出处理函数

- 进程正常退出时的处理函数(异常退出不会执行)

  - atexit()

  ```c++
  void process_exit_deal(void){
    printf("扫尾");
  }
  
  //注册进程退出处理函数,exit正常终止进程时弹栈调用
  atexit(process_exit_deal)
  
  ```

- 线程

  void pthread_cleanup_push(void (*routine)(void *),void * arg)